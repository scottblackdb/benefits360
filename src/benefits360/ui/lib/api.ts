/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * benefits360
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";

import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";

export type ComplexValueDisplay = string | null;

export type ComplexValuePrimary = boolean | null;

export type ComplexValueRef = string | null;

export type ComplexValueType = string | null;

export type ComplexValueValue = string | null;

export interface ComplexValue {
  display?: ComplexValueDisplay;
  primary?: ComplexValuePrimary;
  ref?: ComplexValueRef;
  type?: ComplexValueType;
  value?: ComplexValueValue;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type MedicalParticipantDetailOutFirstName = string | null;

export type MedicalParticipantDetailOutLastName = string | null;

export type MedicalParticipantDetailOutCaseId = string | null;

export type MedicalParticipantDetailOutBirthdate = string | null;

export type MedicalParticipantDetailOutAge = number | null;

export type MedicalParticipantDetailOutGender = string | null;

export type MedicalParticipantDetailOutRace = string | null;

export type MedicalParticipantDetailOutEthnicity = string | null;

export type MedicalParticipantDetailOutIsDisabled = boolean | null;

export type MedicalParticipantDetailOutLanguage = string | null;

export type MedicalParticipantDetailOutHouseholdSize = number | null;

export type MedicalParticipantDetailOutHouseholdType = string | null;

export type MedicalParticipantDetailOutMonthlyIncome = number | null;

export type MedicalParticipantDetailOutAnnualIncome = number | null;

export type MedicalParticipantDetailOutIncomeSource = string | null;

export type MedicalParticipantDetailOutEmploymentStatus = string | null;

export type MedicalParticipantDetailOutEstimatedAssets = number | null;

export type MedicalParticipantDetailOutFplPercentage = number | null;

export type MedicalParticipantDetailOutIncomeEligible = boolean | null;

export type MedicalParticipantDetailOutAssetEligible = boolean | null;

export type MedicalParticipantDetailOutCitizenshipStatus = string | null;

export type MedicalParticipantDetailOutResidencyEligible = boolean | null;

export type MedicalParticipantDetailOutOverallEligible = boolean | null;

export type MedicalParticipantDetailOutCoverageCategory = string | null;

export type MedicalParticipantDetailOutPremiumAmount = number | null;

export type MedicalParticipantDetailOutCopayAmount = number | null;

export type MedicalParticipantDetailOutApplicationDate = string | null;

export type MedicalParticipantDetailOutDecisionDate = string | null;

export type MedicalParticipantDetailOutApplicationStatus = string | null;

export type MedicalParticipantDetailOutEnrollmentDate = string | null;

export type MedicalParticipantDetailOutCounty = string | null;

export interface MedicalParticipantDetailOut {
  first_name?: MedicalParticipantDetailOutFirstName;
  last_name?: MedicalParticipantDetailOutLastName;
  case_id?: MedicalParticipantDetailOutCaseId;
  birthdate?: MedicalParticipantDetailOutBirthdate;
  age?: MedicalParticipantDetailOutAge;
  gender?: MedicalParticipantDetailOutGender;
  race?: MedicalParticipantDetailOutRace;
  ethnicity?: MedicalParticipantDetailOutEthnicity;
  is_disabled?: MedicalParticipantDetailOutIsDisabled;
  language?: MedicalParticipantDetailOutLanguage;
  household_size?: MedicalParticipantDetailOutHouseholdSize;
  household_type?: MedicalParticipantDetailOutHouseholdType;
  monthly_income?: MedicalParticipantDetailOutMonthlyIncome;
  annual_income?: MedicalParticipantDetailOutAnnualIncome;
  income_source?: MedicalParticipantDetailOutIncomeSource;
  employment_status?: MedicalParticipantDetailOutEmploymentStatus;
  estimated_assets?: MedicalParticipantDetailOutEstimatedAssets;
  fpl_percentage?: MedicalParticipantDetailOutFplPercentage;
  income_eligible?: MedicalParticipantDetailOutIncomeEligible;
  asset_eligible?: MedicalParticipantDetailOutAssetEligible;
  citizenship_status?: MedicalParticipantDetailOutCitizenshipStatus;
  residency_eligible?: MedicalParticipantDetailOutResidencyEligible;
  overall_eligible?: MedicalParticipantDetailOutOverallEligible;
  coverage_category?: MedicalParticipantDetailOutCoverageCategory;
  premium_amount?: MedicalParticipantDetailOutPremiumAmount;
  copay_amount?: MedicalParticipantDetailOutCopayAmount;
  application_date?: MedicalParticipantDetailOutApplicationDate;
  decision_date?: MedicalParticipantDetailOutDecisionDate;
  application_status?: MedicalParticipantDetailOutApplicationStatus;
  enrollment_date?: MedicalParticipantDetailOutEnrollmentDate;
  county?: MedicalParticipantDetailOutCounty;
}

export type MedicalParticipantOutName = string | null;

export type MedicalParticipantOutGender = string | null;

export type MedicalParticipantOutBirthdate = string | null;

export type MedicalParticipantOutLanguage = string | null;

export interface MedicalParticipantOut {
  name?: MedicalParticipantOutName;
  gender?: MedicalParticipantOutGender;
  birthdate?: MedicalParticipantOutBirthdate;
  language?: MedicalParticipantOutLanguage;
}

export interface MedicalParticipantsResponse {
  participants: MedicalParticipantOut[];
}

export type NameFamilyName = string | null;

export type NameGivenName = string | null;

export interface Name {
  family_name?: NameFamilyName;
  given_name?: NameGivenName;
}

export type PersonProfileOutPersonId = string | null;

export type PersonProfileOutMedicalId = string | null;

export type PersonProfileOutSnapId = string | null;

export type PersonProfileOutAssistanceId = string | null;

export type PersonProfileOutFirstName = string | null;

export type PersonProfileOutLastName = string | null;

export type PersonProfileOutBirthdate = string | null;

export type PersonProfileOutFullName = string | null;

export interface PersonProfileOut {
  person_id?: PersonProfileOutPersonId;
  medical_id?: PersonProfileOutMedicalId;
  snap_id?: PersonProfileOutSnapId;
  assistance_id?: PersonProfileOutAssistanceId;
  first_name?: PersonProfileOutFirstName;
  last_name?: PersonProfileOutLastName;
  birthdate?: PersonProfileOutBirthdate;
  full_name?: PersonProfileOutFullName;
}

export type SnapParticipantDetailOutSnapId = string | null;

export type SnapParticipantDetailOutFirstName = string | null;

export type SnapParticipantDetailOutLastName = string | null;

export type SnapParticipantDetailOutBirthdate = string | null;

export type SnapParticipantDetailOutAge = number | null;

export type SnapParticipantDetailOutGender = string | null;

export type SnapParticipantDetailOutRace = string | null;

export type SnapParticipantDetailOutEthnicity = string | null;

export type SnapParticipantDetailOutIsDisabled = boolean | null;

export type SnapParticipantDetailOutLanguage = string | null;

export type SnapParticipantDetailOutHouseholdSize = number | null;

export type SnapParticipantDetailOutHouseholdType = string | null;

export type SnapParticipantDetailOutMonthlyIncome = number | null;

export type SnapParticipantDetailOutIncomeSource = string | null;

export type SnapParticipantDetailOutEstimatedAssets = number | null;

export type SnapParticipantDetailOutIncomeLimit = number | null;

export type SnapParticipantDetailOutAssetLimit = number | null;

export type SnapParticipantDetailOutIncomeEligible = boolean | null;

export type SnapParticipantDetailOutAssetEligible = boolean | null;

export type SnapParticipantDetailOutWorkRequirementExempt = boolean | null;

export type SnapParticipantDetailOutOverallEligible = boolean | null;

export type SnapParticipantDetailOutMaxBenefit = number | null;

export type SnapParticipantDetailOutMonthlySnapBenefit = number | null;

export type SnapParticipantDetailOutAnnualSnapBenefit = number | null;

export type SnapParticipantDetailOutSnapApplicationDate = string | null;

export type SnapParticipantDetailOutSnapDecisionDate = string | null;

export type SnapParticipantDetailOutApplicationStatus = string | null;

export interface SnapParticipantDetailOut {
  snap_id?: SnapParticipantDetailOutSnapId;
  first_name?: SnapParticipantDetailOutFirstName;
  last_name?: SnapParticipantDetailOutLastName;
  birthdate?: SnapParticipantDetailOutBirthdate;
  age?: SnapParticipantDetailOutAge;
  gender?: SnapParticipantDetailOutGender;
  race?: SnapParticipantDetailOutRace;
  ethnicity?: SnapParticipantDetailOutEthnicity;
  is_disabled?: SnapParticipantDetailOutIsDisabled;
  language?: SnapParticipantDetailOutLanguage;
  household_size?: SnapParticipantDetailOutHouseholdSize;
  household_type?: SnapParticipantDetailOutHouseholdType;
  monthly_income?: SnapParticipantDetailOutMonthlyIncome;
  income_source?: SnapParticipantDetailOutIncomeSource;
  estimated_assets?: SnapParticipantDetailOutEstimatedAssets;
  income_limit?: SnapParticipantDetailOutIncomeLimit;
  asset_limit?: SnapParticipantDetailOutAssetLimit;
  income_eligible?: SnapParticipantDetailOutIncomeEligible;
  asset_eligible?: SnapParticipantDetailOutAssetEligible;
  work_requirement_exempt?: SnapParticipantDetailOutWorkRequirementExempt;
  overall_eligible?: SnapParticipantDetailOutOverallEligible;
  max_benefit?: SnapParticipantDetailOutMaxBenefit;
  monthly_snap_benefit?: SnapParticipantDetailOutMonthlySnapBenefit;
  annual_snap_benefit?: SnapParticipantDetailOutAnnualSnapBenefit;
  snap_application_date?: SnapParticipantDetailOutSnapApplicationDate;
  snap_decision_date?: SnapParticipantDetailOutSnapDecisionDate;
  application_status?: SnapParticipantDetailOutApplicationStatus;
}

export type TimelineEventOutAApplicationDate = string | null;

export type TimelineEventOutAssistanceType = string | null;

export type TimelineEventOutAApplicationStatus = string | null;

export type TimelineEventOutADecisionDate = string | null;

export type TimelineEventOutMApplicationDate = string | null;

export type TimelineEventOutMApplicationState = string | null;

export type TimelineEventOutMDecisionDate = string | null;

export type TimelineEventOutSnapApplicationDate = string | null;

export type TimelineEventOutSApplicationState = string | null;

export type TimelineEventOutSnapDecisionDate = string | null;

export interface TimelineEventOut {
  a_application_date?: TimelineEventOutAApplicationDate;
  assistance_type?: TimelineEventOutAssistanceType;
  a_application_status?: TimelineEventOutAApplicationStatus;
  a_decision_date?: TimelineEventOutADecisionDate;
  m_application_date?: TimelineEventOutMApplicationDate;
  m_application_state?: TimelineEventOutMApplicationState;
  m_decision_date?: TimelineEventOutMDecisionDate;
  snap_application_date?: TimelineEventOutSnapApplicationDate;
  s_application_state?: TimelineEventOutSApplicationState;
  snap_decision_date?: TimelineEventOutSnapDecisionDate;
}

export interface TimelineResponse {
  events: TimelineEventOut[];
}

export type UserActive = boolean | null;

export type UserDisplayName = string | null;

export type UserEmails = ComplexValue[] | null;

export type UserEntitlements = ComplexValue[] | null;

export type UserExternalId = string | null;

export type UserGroups = ComplexValue[] | null;

export type UserId = string | null;

export type UserName = Name | null;

export type UserRoles = ComplexValue[] | null;

export type UserSchemas = UserSchema[] | null;

export type UserUserName = string | null;

export interface User {
  active?: UserActive;
  display_name?: UserDisplayName;
  emails?: UserEmails;
  entitlements?: UserEntitlements;
  external_id?: UserExternalId;
  groups?: UserGroups;
  id?: UserId;
  name?: UserName;
  roles?: UserRoles;
  schemas?: UserSchemas;
  user_name?: UserUserName;
}

export type UserSchema = (typeof UserSchema)[keyof typeof UserSchema];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSchema = {
  "urn:ietf:params:scim:schemas:core:20:User":
    "urn:ietf:params:scim:schemas:core:2.0:User",
  "urn:ietf:params:scim:schemas:extension:workspace:20:User":
    "urn:ietf:params:scim:schemas:extension:workspace:2.0:User",
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type VectorSearchRequestLimit = number | null;

export interface VectorSearchRequest {
  query: string;
  endpoint_name?: string;
  index_name?: string;
  limit?: VectorSearchRequestLimit;
}

export interface VectorSearchResponse {
  results: VectorSearchResult[];
  query: string;
}

export type VectorSearchResultScore = number | null;

export type VectorSearchResultData = { [key: string]: unknown };

export interface VectorSearchResult {
  score?: VectorSearchResultScore;
  data: VectorSearchResultData;
}

export interface VersionOut {
  version: string;
}

export type GetMedicalParticipantsParams = {
  /**
   * First name to search for
   */
  first_name: string;
  /**
   * Last name to search for
   */
  last_name: string;
  /**
   * Birthdate to search for (YYYY-MM-DD format)
   */
  birthdate: string;
};

/**
 * @summary Version
 */
export const version = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VersionOut>> => {
  return axios.default.get(`/api/version`, options);
};

export const getVersionQueryKey = () => {
  return [`/api/version`] as const;
};

export const getVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionQueryError = AxiosError<unknown>;

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof version>>,
          TError,
          Awaited<ReturnType<typeof version>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersion<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVersionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof version>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVersionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof version>>> = ({
    signal,
  }) => version({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof version>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof version>>
>;
export type VersionSuspenseQueryError = AxiosError<unknown>;

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Version
 */

export function useVersionSuspense<
  TData = Awaited<ReturnType<typeof version>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof version>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVersionSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Me
 */
export const currentUser = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<User>> => {
  return axios.default.get(`/api/current-user`, options);
};

export const getCurrentUserQueryKey = () => {
  return [`/api/current-user`] as const;
};

export const getCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({
    signal,
  }) => currentUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof currentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof currentUser>>
>;
export type CurrentUserQueryError = AxiosError<HTTPValidationError>;

export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof currentUser>>,
          TError,
          Awaited<ReturnType<typeof currentUser>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Me
 */

export function useCurrentUser<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof currentUser>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCurrentUserSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof currentUser>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof currentUser>>> = ({
    signal,
  }) => currentUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof currentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CurrentUserSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof currentUser>>
>;
export type CurrentUserSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Me
 */

export function useCurrentUserSuspense<
  TData = Awaited<ReturnType<typeof currentUser>>,
  TError = AxiosError<HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof currentUser>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCurrentUserSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Search for people using vector search on the vector index.
Performs pure vector similarity search (no hybrid/full-text search).
 * @summary Search People
 */
export const searchPeople = (
  vectorSearchRequest: VectorSearchRequest,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<VectorSearchResponse>> => {
  return axios.default.post(`/api/search`, vectorSearchRequest, options);
};

export const getSearchPeopleMutationOptions = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchPeople>>,
    TError,
    { data: VectorSearchRequest },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchPeople>>,
  TError,
  { data: VectorSearchRequest },
  TContext
> => {
  const mutationKey = ["searchPeople"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchPeople>>,
    { data: VectorSearchRequest }
  > = (props) => {
    const { data } = props ?? {};

    return searchPeople(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchPeopleMutationResult = NonNullable<
  Awaited<ReturnType<typeof searchPeople>>
>;
export type SearchPeopleMutationBody = VectorSearchRequest;
export type SearchPeopleMutationError = AxiosError<HTTPValidationError>;

/**
 * @summary Search People
 */
export const useSearchPeople = <
  TError = AxiosError<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof searchPeople>>,
      TError,
      { data: VectorSearchRequest },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof searchPeople>>,
  TError,
  { data: VectorSearchRequest },
  TContext
> => {
  const mutationOptions = getSearchPeopleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Get a person's profile from the benefits360.silver.people_index table using DBSQL.
Falls back to matched_people table if not found in people_index.
 * @summary Get Person Profile
 */
export const getPersonProfile = (
  personId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PersonProfileOut>> => {
  return axios.default.get(`/api/profile/${personId}`, options);
};

export const getGetPersonProfileQueryKey = (personId?: string) => {
  return [`/api/profile/${personId}`] as const;
};

export const getGetPersonProfileQueryOptions = <
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPersonProfileQueryKey(personId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPersonProfile>>
  > = ({ signal }) => getPersonProfile(personId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!personId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPersonProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPersonProfileQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPersonProfile>>
>;
export type GetPersonProfileQueryError = AxiosError<HTTPValidationError>;

export function useGetPersonProfile<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonProfile>>,
          TError,
          Awaited<ReturnType<typeof getPersonProfile>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPersonProfile<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPersonProfile>>,
          TError,
          Awaited<ReturnType<typeof getPersonProfile>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPersonProfile<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Person Profile
 */

export function useGetPersonProfile<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPersonProfileQueryOptions(personId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPersonProfileSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPersonProfileQueryKey(personId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPersonProfile>>
  > = ({ signal }) => getPersonProfile(personId, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getPersonProfile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPersonProfileSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPersonProfile>>
>;
export type GetPersonProfileSuspenseQueryError =
  AxiosError<HTTPValidationError>;

export function useGetPersonProfileSuspense<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPersonProfileSuspense<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPersonProfileSuspense<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Person Profile
 */

export function useGetPersonProfileSuspense<
  TData = Awaited<ReturnType<typeof getPersonProfile>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getPersonProfile>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPersonProfileSuspenseQueryOptions(
    personId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get medical participants from the benefits360.bronze.medical_participants table
by matching first_name, last_name, and birthdate.
 * @summary Get Medical Participants
 */
export const getMedicalParticipants = (
  params: GetMedicalParticipantsParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MedicalParticipantsResponse>> => {
  return axios.default.get(`/api/medical-participants`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getGetMedicalParticipantsQueryKey = (
  params?: GetMedicalParticipantsParams,
) => {
  return [`/api/medical-participants`, ...(params ? [params] : [])] as const;
};

export const getGetMedicalParticipantsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMedicalParticipantsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMedicalParticipants>>
  > = ({ signal }) =>
    getMedicalParticipants(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMedicalParticipants>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMedicalParticipantsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMedicalParticipants>>
>;
export type GetMedicalParticipantsQueryError = AxiosError<HTTPValidationError>;

export function useGetMedicalParticipants<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMedicalParticipants>>,
          TError,
          Awaited<ReturnType<typeof getMedicalParticipants>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipants<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMedicalParticipants>>,
          TError,
          Awaited<ReturnType<typeof getMedicalParticipants>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipants<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Medical Participants
 */

export function useGetMedicalParticipants<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMedicalParticipantsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMedicalParticipantsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMedicalParticipantsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMedicalParticipants>>
  > = ({ signal }) =>
    getMedicalParticipants(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getMedicalParticipants>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMedicalParticipantsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMedicalParticipants>>
>;
export type GetMedicalParticipantsSuspenseQueryError =
  AxiosError<HTTPValidationError>;

export function useGetMedicalParticipantsSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipantsSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipantsSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Medical Participants
 */

export function useGetMedicalParticipantsSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipants>>,
  TError = AxiosError<HTTPValidationError>,
>(
  params: GetMedicalParticipantsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipants>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMedicalParticipantsSuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get timeline events for a person by joining assistance, medical, and SNAP data.
 * @summary Get Timeline
 */
export const getTimeline = (
  personId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TimelineResponse>> => {
  return axios.default.get(`/api/timeline/${personId}`, options);
};

export const getGetTimelineQueryKey = (personId?: string) => {
  return [`/api/timeline/${personId}`] as const;
};

export const getGetTimelineQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimelineQueryKey(personId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({
    signal,
  }) => getTimeline(personId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!personId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeline>>
>;
export type GetTimelineQueryError = AxiosError<HTTPValidationError>;

export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          Awaited<ReturnType<typeof getTimeline>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          Awaited<ReturnType<typeof getTimeline>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Timeline
 */

export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelineQueryOptions(personId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTimelineSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimelineQueryKey(personId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({
    signal,
  }) => getTimeline(personId, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelineSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeline>>
>;
export type GetTimelineSuspenseQueryError = AxiosError<HTTPValidationError>;

export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Timeline
 */

export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = AxiosError<HTTPValidationError>,
>(
  personId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelineSuspenseQueryOptions(personId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get SNAP participant details from the benefits360.bronze.snap_participants table.
 * @summary Get Snap Participant
 */
export const getSnapParticipant = (
  snapId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<SnapParticipantDetailOut>> => {
  return axios.default.get(`/api/snap-participant/${snapId}`, options);
};

export const getGetSnapParticipantQueryKey = (snapId?: string) => {
  return [`/api/snap-participant/${snapId}`] as const;
};

export const getGetSnapParticipantQueryOptions = <
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSnapParticipantQueryKey(snapId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSnapParticipant>>
  > = ({ signal }) => getSnapParticipant(snapId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!snapId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSnapParticipant>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSnapParticipantQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSnapParticipant>>
>;
export type GetSnapParticipantQueryError = AxiosError<HTTPValidationError>;

export function useGetSnapParticipant<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSnapParticipant>>,
          TError,
          Awaited<ReturnType<typeof getSnapParticipant>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSnapParticipant<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSnapParticipant>>,
          TError,
          Awaited<ReturnType<typeof getSnapParticipant>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSnapParticipant<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Snap Participant
 */

export function useGetSnapParticipant<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSnapParticipantQueryOptions(snapId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSnapParticipantSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSnapParticipantQueryKey(snapId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSnapParticipant>>
  > = ({ signal }) => getSnapParticipant(snapId, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSnapParticipant>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSnapParticipantSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSnapParticipant>>
>;
export type GetSnapParticipantSuspenseQueryError =
  AxiosError<HTTPValidationError>;

export function useGetSnapParticipantSuspense<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSnapParticipantSuspense<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSnapParticipantSuspense<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Snap Participant
 */

export function useGetSnapParticipantSuspense<
  TData = Awaited<ReturnType<typeof getSnapParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  snapId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSnapParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSnapParticipantSuspenseQueryOptions(
    snapId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get Medical participant details from the benefits360.bronze.medical_participants table.
 * @summary Get Medical Participant
 */
export const getMedicalParticipant = (
  caseId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<MedicalParticipantDetailOut>> => {
  return axios.default.get(`/api/medical-participant/${caseId}`, options);
};

export const getGetMedicalParticipantQueryKey = (caseId?: string) => {
  return [`/api/medical-participant/${caseId}`] as const;
};

export const getGetMedicalParticipantQueryOptions = <
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMedicalParticipantQueryKey(caseId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMedicalParticipant>>
  > = ({ signal }) =>
    getMedicalParticipant(caseId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!caseId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMedicalParticipant>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMedicalParticipantQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMedicalParticipant>>
>;
export type GetMedicalParticipantQueryError = AxiosError<HTTPValidationError>;

export function useGetMedicalParticipant<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMedicalParticipant>>,
          TError,
          Awaited<ReturnType<typeof getMedicalParticipant>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipant<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMedicalParticipant>>,
          TError,
          Awaited<ReturnType<typeof getMedicalParticipant>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipant<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Medical Participant
 */

export function useGetMedicalParticipant<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMedicalParticipantQueryOptions(caseId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMedicalParticipantSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMedicalParticipantQueryKey(caseId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMedicalParticipant>>
  > = ({ signal }) =>
    getMedicalParticipant(caseId, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getMedicalParticipant>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMedicalParticipantSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMedicalParticipant>>
>;
export type GetMedicalParticipantSuspenseQueryError =
  AxiosError<HTTPValidationError>;

export function useGetMedicalParticipantSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipantSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMedicalParticipantSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Medical Participant
 */

export function useGetMedicalParticipantSuspense<
  TData = Awaited<ReturnType<typeof getMedicalParticipant>>,
  TError = AxiosError<HTTPValidationError>,
>(
  caseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMedicalParticipant>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMedicalParticipantSuspenseQueryOptions(
    caseId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
